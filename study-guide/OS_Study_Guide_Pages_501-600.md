# Operating Systems - Exam-Oriented Study Guide
## Pages 501-600: alarm(), Pipes, IPC, Threads ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

**CRITICAL EXAM MATERIAL - Pipes are Heavily Tested!**

**Previous Sections:** Pages 1-500 covered commands, file I/O, fork(), wait(), exec(), signals

---

## ‚ö†Ô∏è EXAM IMPORTANCE ‚ö†Ô∏è

**This section represents approximately 20-25% of exam content:**
- **Pipes** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê - **MOST TESTED in this section**
- **alarm() and signal timing** ‚≠ê‚≠ê‚≠ê - Common exam pattern
- **IPC concepts** ‚≠ê‚≠ê‚≠ê - Important theory
- **Threads introduction** ‚≠ê‚≠ê - Background for synchronization

**Pipes alone account for 15-20 exam questions! Master them completely!**

---

## SECTION 30: alarm() System Call Details ‚≠ê‚≠ê‚≠ê‚≠ê
**Slides 30-36 | Exam Relevance: High**

### 30.1 alarm() Basics ‚≠ê‚≠ê‚≠ê‚≠ê

**System Call:**
```c
#include <unistd.h>

unsigned int alarm(unsigned int seconds);

// Returns:
//   - Seconds remaining from previous alarm
//   - 0 if no previous alarm was set
```

**What alarm() Does:**
1. Activates a timer (countdown)
2. After `seconds` elapse, kernel generates SIGALRM
3. Default action: terminate process (if not caught)

**Key Behaviors:**
- Only ONE alarm per process at a time
- New alarm() cancels previous alarm
- alarm(0) cancels existing alarm

### 30.2 alarm() Examples ‚≠ê‚≠ê‚≠ê‚≠ê

**Example 1: Basic Alarm**
```c
void alarm_handler(int sig) {
    printf("Time's up!\n");
    exit(0);
}

int main() {
    signal(SIGALRM, alarm_handler);
    alarm(5);  // Set 5-second alarm
    
    printf("Doing work...\n");
    while(1) {
        // Work continues until alarm fires
    }
    
    return 0;
}
```

**Example 2: Implementing sleep() with alarm()**
```c
static void sig_alrm(int signo) {
    return;  // Just wake up from pause
}

unsigned int sleep1(unsigned int nsecs) {
    if (signal(SIGALRM, sig_alrm) == SIG_ERR)
        return nsecs;
    
    alarm(nsecs);       // Set alarm
    pause();            // Wait for signal
    return alarm(0);    // Return remaining time
}
```

**CRITICAL Order:**
1. **Install handler FIRST**
2. **Then set alarm**
3. **Then pause/wait**

**Example 3: Implementing alarm() with fork()**
```c
void myAlarm(int sig) {
    if (sig == SIGALRM)
        printf("Alarm on ...\n");
    return;
}

int main(void) {
    pid_t pid;
    
    signal(SIGALRM, myAlarm);
    
    pid = fork();
    if (pid == -1) {
        printf("fork failed");
        exit(1);
    }
    
    if (pid == 0) {
        // Child: wait then send signal
        sleep(5);
        kill(getppid(), SIGALRM);
        exit(0);
    }
    
    // Parent: wait for signal
    pause();
    exit(0);
}
```

### 30.3 alarm() Important Notes ‚≠ê‚≠ê‚≠ê‚≠ê

**Timing Issues:**
- Signal generated by kernel
- Process may not get CPU immediately
- Scheduler determines when process runs
- Actual response time > requested time

**Shared Timer:**
- Only ONE timer per process
- sleep() and alarm() use same kernel timer
- Using both can cause conflicts!

**Canceling Alarm:**
```c
alarm(10);     // Set 10-second alarm
// ... do some work ...
alarm(0);      // Cancel alarm
```

**Checking Remaining Time:**
```c
unsigned int remaining = alarm(5);  // Set new, get old remaining
printf("Previous alarm had %u seconds left\n", remaining);
```

### What to Memorize

**alarm() Basics:**
- [ ] alarm(seconds) - set countdown
- [ ] Generates SIGALRM when expires
- [ ] alarm(0) cancels alarm
- [ ] Returns remaining time from previous

**Usage Pattern:**
- [ ] signal() first, then alarm()
- [ ] Only one alarm per process
- [ ] Shared timer with sleep()

**Implementation:**
- [ ] Can implement sleep() using alarm + pause
- [ ] Can implement alarm() using fork + sleep + kill

---

## SECTION 31: Signal Limitations ‚≠ê‚≠ê‚≠ê
**Slides 37-51 | Exam Relevance: Medium-High**

### 31.1 Signal Memory Limitations ‚≠ê‚≠ê‚≠ê

**CRITICAL Limitation:**
- **At most ONE pending signal per type**
- If signal already pending, new signals of same type are **LOST**

**Example:**
```c
void sigUsr1(int signo) {
    printf("Received SIGUSR1\n");
    sleep(5);  // Handler takes 5 seconds
    return;
}

signal(SIGUSR1, sigUsr1);
pause();
```

**Send 3 SIGUSR1 in sequence:**
```bash
$ kill -USR1 $PID ; kill -USR1 $PID ; kill -USR1 $PID
```

**Result:**
- First SIGUSR1: delivered, handler runs
- Second SIGUSR1: pending (waits for handler)
- Third SIGUSR1: **LOST** (only one pending allowed)

**Only 2 "Received SIGUSR1" messages print!**

### 31.2 Reentrant Functions ‚≠ê‚≠ê‚≠ê

**Reentrant Function:**
- Can be safely interrupted
- Can be called again before previous call completes
- No corruption of state

**Problem with Non-Reentrant Functions:**

**Example 1: malloc()**
```c
void handler(int sig) {
    char *p = malloc(100);  // DANGEROUS!
    // malloc might corrupt free list
}

int main() {
    signal(SIGUSR1, handler);
    char *p = malloc(100);  // If interrupted here...
    // malloc's internal structures may be inconsistent
}
```

**Example 2: Static Variables**
```c
int count_calls() {
    static int count = 0;  // DANGEROUS!
    count++;
    return count;
}

void handler(int sig) {
    count_calls();  // Modifies static variable
}

int main() {
    signal(SIGUSR1, handler);
    int n = count_calls();  // If interrupted...
    // Static variable corrupted
}
```

**Reentrant Functions (SAFE):**
- read, write
- wait, waitpid
- sleep
- Most system calls

**Non-Reentrant Functions (UNSAFE):**
- printf, scanf
- malloc, free
- Functions using static/global variables
- Most stdio functions

**Best Practice:**
```c
void handler(int sig) {
    // Keep it simple!
    // Set flag, don't do complex work
    volatile sig_atomic_t flag = 1;
}
```

### 31.3 Race Conditions with Signals ‚≠ê‚≠ê‚≠ê‚≠ê

**Race Condition:**
Result depends on timing/order of operations.

**Example A: alarm/pause Race**
```c
void handler(int sig) { }

signal(SIGALRM, handler);
alarm(nSec);
pause();  // RACE CONDITION!
```

**Problem:**
1. alarm() sets timer
2. **Context switch occurs**
3. SIGALRM delivered **before** pause()
4. pause() executes
5. **Process blocked forever!** (signal already delivered)

**Example B: Signal Synchronization Race**
```c
// Process P1
while (1) {
    // Do work
    kill(pidP2, SIGUSR1);
    pause();  // Wait for P2's signal
}

// Process P2
while (1) {
    pause();  // Wait for P1's signal
    // Do work
    kill(pidP1, SIGUSR1);
}
```

**Problem:**
- If P1's signal arrives before P2's pause()
- P2 blocks forever waiting for signal that already arrived

**Partial Solution (Exam Context):**
```c
// Use sleep() for rough synchronization
kill(pidP2, SIGUSR1);
sleep(1);  // Give time for other process
pause();
```

**Note:** Exam questions often say "ignoring race conditions" - acknowledge but proceed with solution.

### What to Memorize

**Signal Limitations:**
- [ ] Max one pending signal per type
- [ ] Additional signals of same type lost
- [ ] No signal queue in most UNIX systems

**Reentrant Functions:**
- [ ] Safe: read, write, wait, sleep
- [ ] Unsafe: printf, malloc, static variables
- [ ] Keep handlers simple

**Race Conditions:**
- [ ] alarm before pause = potential race
- [ ] Signal before pause = lost signal
- [ ] Use sleep() for rough sync (exam context)

---

## SECTION 32: Shell Process Commands ‚≠ê‚≠ê
**Slides 2-9 | Exam Relevance: Low-Medium**

### 32.1 Foreground vs Background ‚≠ê‚≠ê

**Foreground Execution:**
```bash
$ command1
# Shell waits for command1 to finish
# Then displays prompt

$ command1; command2; command3
# Sequential execution
```

**Background Execution:**
```bash
$ command1 &
# Shell returns prompt immediately
# command1 runs concurrently with shell

$ command1 & command2 &
# Both run in parallel
```

### 32.2 Process Status Commands ‚≠ê‚≠ê

**ps (Process Status):**
```bash
$ ps              # User's processes
$ ps -a           # All users
$ ps -u           # Detailed info (memory, etc.)
$ ps -u username  # Specific user
$ ps -x           # Include daemons
$ ps -e           # All processes
$ ps -f           # Full format
$ ps r            # Only running processes

$ ps -aux         # Common: all users, detailed
```

**top:**
- Dynamic process viewer
- Shows CPU, memory usage
- Updates in real-time

**kill:**
```bash
$ kill -l         # List available signals
$ kill PID        # Send SIGTERM (default)
$ kill -9 PID     # Send SIGKILL
$ kill -SIGTERM PID
$ kill -KILL PID
$ killall name    # Kill all processes with name
```

### What to Know (Brief)

- Foreground: shell waits
- Background (&): shell continues
- ps: view process status
- kill: send signals
- **Low exam impact** - basic shell knowledge

---

## SECTION 33: IPC Concepts ‚≠ê‚≠ê‚≠ê
**Slides 2-9 (IPC chapter) | Exam Relevance: Medium**

### 33.1 Process Types ‚≠ê‚≠ê‚≠ê

**Independent Processes:**
- Cannot be influenced by others
- Cannot influence others
- No communication needed

**Cooperating Processes:**
- Share data
- Exchange messages
- Require synchronization

### 33.2 IPC Models ‚≠ê‚≠ê‚≠ê‚≠ê

**Two Main Models:**

**1. Shared Memory**
```
Process A ‚Üê‚Üí Shared Memory Area ‚Üê‚Üí Process B
```

**Characteristics:**
- Processes share memory region
- Direct memory access
- **Fast** (no kernel intervention after setup)
- Good for **large data** transfer
- Requires synchronization

**Methods:**
- Regular files
- Memory-mapped files
- Shared memory segments

**2. Message Passing**
```
Process A ‚Üí Kernel ‚Üí Process B
```

**Characteristics:**
- Exchange messages through kernel
- No shared memory needed
- **Slower** (kernel overhead)
- Good for **small data** transfer
- Easier synchronization

**Methods:**
- Pipes
- FIFOs
- Message queues
- Sockets

### 33.3 Communication Channels ‚≠ê‚≠ê‚≠ê

**Direct vs Indirect:**

**Direct:**
```c
send(to_process, message);
receive(from_process, &message);
```
- Name sender/receiver explicitly

**Indirect (Mailbox):**
```c
send(mailboxAddress, message);
receive(mailboxAddress, &message);
```
- Use shared mailbox address

**Synchronization:**
- **Synchronous (Blocking):** Sender/receiver waits
- **Asynchronous (Non-blocking):** Continue immediately

**Capacity:**
- **Zero:** No buffering, sender blocks until receiver ready
- **Limited:** Sender blocks when buffer full
- **Unlimited:** Sender never blocks

### What to Memorize

**IPC Models:**
- [ ] Shared memory: fast, large data
- [ ] Message passing: slower, small data

**Communication Types:**
- [ ] Direct: name processes
- [ ] Indirect: use mailbox
- [ ] Synchronous: blocking
- [ ] Asynchronous: non-blocking

---

## SECTION 34: Pipes ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
**Slides 10-37 (IPC chapter) | Exam Relevance: MAXIMUM CRITICAL!**

**THIS IS THE MOST TESTED MATERIAL IN PAGES 501-600!**

### 34.1 Pipe Concepts ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

**What is a Pipe:**
- Oldest form of UNIX IPC
- Unidirectional data channel
- In-memory buffer (not file system)
- Two file descriptors: one for read, one for write

**Characteristics:**
- **Direct communication** (between processes)
- **Asynchronous** (buffered)
- **Limited capacity** (buffer size)
- **Half-duplex** (data flows one direction at a time)

**Simplex vs Half-Duplex vs Full-Duplex:**
```
Simplex:     P1 ‚Üí‚Üí‚Üí‚Üí‚Üí P2       (one-way only)
Half-Duplex: P1 ‚Üê‚Üí‚Üê‚Üí‚Üê P2       (both ways, but not simultaneously)
Full-Duplex: P1 ‚áÑ‚áÑ‚áÑ‚áÑ‚áÑ P2       (both ways simultaneously)
```

**UNIX pipes are half-duplex** (for synchronization reasons)

### 34.2 pipe() System Call ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

**System Call:**
```c
#include <unistd.h>

int pipe(int fileDescr[2]);

// Returns: 0 on success, -1 on error
```

**File Descriptors:**
```c
int fd[2];
pipe(fd);

fd[0]  // Read end
fd[1]  // Write end

// Data written to fd[1] can be read from fd[0]
```

**CRITICAL:** Pipe must be created **BEFORE** fork()!

### 34.3 Pipe Usage Pattern ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

**Standard Pattern (MEMORIZE!):**

```c
int fd[2];
pid_t pid;

// 1. Create pipe FIRST
pipe(fd);

// 2. Then fork
pid = fork();

if (pid == 0) {
    // Child: will read from pipe
    close(fd[1]);   // Close unused write end
    
    // Read from pipe
    read(fd[0], buffer, size);
    
    close(fd[0]);
    exit(0);
} else {
    // Parent: will write to pipe
    close(fd[0]);   // Close unused read end
    
    // Write to pipe
    write(fd[1], data, size);
    
    close(fd[1]);   // CRITICAL: must close!
    wait(NULL);
}
```

**Execution Flow:**
```
1. Parent creates pipe:  [fd[0] | fd[1]]
2. Parent forks
3. Both have file descriptors:
   Parent: [fd[0] | fd[1]]
   Child:  [fd[0] | fd[1]]
4. Close unused ends:
   Parent: [  X   | fd[1]]  (writes)
   Child:  [fd[0] |   X  ]  (reads)
5. Communicate through pipe
6. Close remaining ends
```

### 34.4 Pipe I/O Behavior ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

**read() Behavior:**

**Case 1: Data Available**
```c
n = read(fd[0], buf, 100);
// Returns: number of bytes read (1 to 100)
```

**Case 2: Pipe Empty, Writer Exists**
```c
n = read(fd[0], buf, 100);
// BLOCKS until data available
```

**Case 3: Pipe Empty, All Writers Closed**
```c
n = read(fd[0], buf, 100);
// Returns: 0 (EOF)
```

**write() Behavior:**

**Case 1: Pipe Has Space**
```c
n = write(fd[1], data, 100);
// Returns: 100 (bytes written)
```

**Case 2: Pipe Full**
```c
n = write(fd[1], data, 100);
// BLOCKS until space available
```

**Case 3: All Readers Closed**
```c
n = write(fd[1], data, 100);
// Generates SIGPIPE signal
// Default: terminate process
```

**PIPE_BUF:**
- Maximum atomic write size
- Typically 4096 bytes on Linux
- Writes ‚â§ PIPE_BUF are atomic

### 34.5 Pipe Closing - CRITICAL! ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

**Why Closing is Essential:**

**Problem Without Close:**
```c
if (pid > 0) {
    // Parent writes
    write(fd[1], "Hello", 5);
    // Doesn't close fd[1]!
    wait(NULL);
} else {
    // Child reads
    while ((n = read(fd[0], &c, 1)) > 0) {
        printf("%c", c);
    }
    // BLOCKS FOREVER!
    // read() never sees EOF because parent still has fd[1] open
}
```

**Correct Version:**
```c
if (pid > 0) {
    // Parent writes
    close(fd[0]);    // Close unused read end
    write(fd[1], "Hello", 5);
    close(fd[1]);    // Close write end - CRITICAL!
    wait(NULL);
} else {
    // Child reads
    close(fd[1]);    // Close unused write end
    while ((n = read(fd[0], &c, 1)) > 0) {
        printf("%c", c);
    }
    // read() returns 0 (EOF) because all writers closed
    printf("Done\n");
}
```

**RULE:** **Close ALL unused file descriptors immediately!**

### 34.6 Pipe Examples ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

**Example 1: Single Character Transfer**
```c
int main() {
    int fd[2];
    char cW = 'x', cR;
    pid_t pid;
    
    pipe(fd);  // Create pipe first
    
    pid = fork();
    if (pid == 0) {
        // Child: read
        close(fd[1]);
        read(fd[0], &cR, 1);
        printf("Read: %c\n", cR);
        close(fd[0]);
        exit(0);
    } else {
        // Parent: write
        close(fd[0]);
        write(fd[1], &cW, 1);
        printf("Wrote: %c\n", cW);
        close(fd[1]);
        wait(NULL);
    }
    
    return 0;
}
```

**Example 2: String Transfer**
```c
if (pid > 0) {
    // Parent: write string
    close(fd[0]);
    write(fd[1], "Hi Child!", 9);
    close(fd[1]);  // MUST close!
    wait(NULL);
} else {
    // Child: read until EOF
    close(fd[1]);
    char c;
    while (read(fd[0], &c, 1) > 0) {
        printf("%c", c);
    }
    printf("\nDone\n");
    close(fd[0]);
}
```

**Example 3: Finding Pipe Size**
```c
int fd[2];
pipe(fd);

if (fork()) {
    // Parent: write until blocked
    int n = 0;
    char c = '1';
    
    close(fd[0]);
    sleep(1);  // Let child sleep
    
    while (1) {
        write(fd[1], &c, 1);  // Write one byte
        n++;
        printf("Wrote %d bytes\r", n);
    }
} else {
    // Child: sleep, then read
    close(fd[1]);
    sleep(10);  // Don't read for 10 seconds
    
    // When child starts reading, parent can continue
    char c;
    while (read(fd[0], &c, 1) > 0) {
        printf("Reading...\n");
    }
}
```

**Output:**
```
Wrote 65536 bytes
(Parent blocks - pipe full!)
(After 10 seconds, child reads)
Wrote 100000 bytes
...
```

**Pipe size typically 65536 bytes (64 KB)**

### 34.7 Bidirectional Communication ‚≠ê‚≠ê‚≠ê‚≠ê

**Half-Duplex Alternating:**
```c
int fd[2];
pipe(fd);

if (fork()) {
    // Parent: write then read
    while (1) {
        // Write to child
        write(fd[1], "P", 1);
        sleep(2);
        
        // Read from child
        read(fd[0], &c, 1);
        printf("Parent read: %c\n", c);
        sleep(2);
    }
} else {
    // Child: read then write
    while (1) {
        // Read from parent
        read(fd[0], &c, 1);
        printf("Child read: %c\n", c);
        sleep(2);
        
        // Write to parent
        write(fd[1], "C", 1);
        sleep(2);
    }
}
```

**Works because operations alternate!**
Without sleep(), race conditions possible.

**Full Bidirectional (Two Pipes):**
```c
int pipe1[2], pipe2[2];

pipe(pipe1);  // Parent ‚Üí Child
pipe(pipe2);  // Child ‚Üí Parent

if (fork()) {
    // Parent
    close(pipe1[0]);  // Won't read from pipe1
    close(pipe2[1]);  // Won't write to pipe2
    
    write(pipe1[1], "Hello", 5);  // Send to child
    read(pipe2[0], buf, 100);      // Receive from child
} else {
    // Child
    close(pipe1[1]);  // Won't write to pipe1
    close(pipe2[0]);  // Won't read from pipe2
    
    read(pipe1[0], buf, 100);      // Receive from parent
    write(pipe2[1], "World", 5);   // Send to parent
}
```

### What to Memorize

**Pipe Creation:**
- [ ] pipe(fd) before fork()
- [ ] fd[0] = read end
- [ ] fd[1] = write end

**Usage Pattern:**
- [ ] Create pipe
- [ ] Fork
- [ ] Close unused ends
- [ ] Read/write
- [ ] Close used ends

**read() Returns:**
- [ ] n > 0: bytes read
- [ ] 0: EOF (all writers closed)
- [ ] -1: error
- [ ] Blocks if empty and writers exist

**write() Behavior:**
- [ ] Returns bytes written
- [ ] Blocks if pipe full
- [ ] SIGPIPE if all readers closed

**CRITICAL:**
- [ ] MUST close unused ends
- [ ] MUST close write end for EOF
- [ ] Pipe created BEFORE fork

### Common Exam Patterns

**Pattern 1: Basic Pipe Communication**
"Write a program where parent sends message to child"
```c
pipe(fd);
fork();
if (child) {
    close(fd[1]);
    read(fd[0], buf, n);
} else {
    close(fd[0]);
    write(fd[1], msg, len);
    close(fd[1]);
}
```

**Pattern 2: Why Program Hangs**
```c
// PROBLEM: Doesn't close fd[1]
if (parent) {
    write(fd[1], "X", 1);
    wait(NULL);  // Waits forever!
} else {
    while (read(fd[0], &c, 1) > 0)  // Never gets EOF
        printf("%c", c);
}
```

**Pattern 3: Pipe Size**
"How large is the pipe buffer?"
- Write until blocked
- Count bytes written
- Typically 64 KB (65536 bytes)

---

## SECTION 35: Shell Pipes and Redirection ‚≠ê‚≠ê‚≠ê
**Slides 2-11 (Shell chapter) | Exam Relevance: Medium**

### 35.1 Shell Pipes ‚≠ê‚≠ê‚≠ê

**Pipe Operator (|):**
```bash
command1 | command2
```
- Connects stdout of command1 to stdin of command2

**Examples:**
```bash
$ ls -la | more          # Page through directory listing
$ ps | grep main         # Filter processes
$ cat file1 file2 | sort # Sort combined files
$ ls -laR *.c | wc       # Count lines in all .c files

# Multiple pipes
$ cat file | sort | uniq | wc -l
```

### 35.2 I/O Redirection ‚≠ê‚≠ê‚≠ê

**Standard Streams:**
- stdin (0): standard input
- stdout (1): standard output
- stderr (2): standard error

**Input Redirection:**
```bash
$ command < file         # Read from file
$ command << EOF         # Here document
data
EOF
```

**Output Redirection:**
```bash
$ command > file         # Overwrite file
$ command 1> file        # Same (1 is default)
$ command >> file        # Append to file
```

**Error Redirection:**
```bash
$ command 2> file        # Redirect stderr
$ command 2>> file       # Append stderr
```

**Both Streams:**
```bash
$ command &> file        # Both stdout and stderr
$ command &>> file       # Append both

# Separate files (Bash)
$ command 1> out.txt 2> err.txt

# Separate files (Tcsh)
$ command > out.txt >& err.txt
```

**Special File:**
```bash
$ command > /dev/null    # Discard output
$ command 2> /dev/null   # Discard errors
$ command &> /dev/null   # Discard everything
```

### 35.3 Combined Usage ‚≠ê‚≠ê‚≠ê

**Examples:**
```bash
# Redirect input and output
$ sort < input.txt > output.txt

# Pipe with redirection
$ ls -la | grep "\.c$" > c_files.txt

# Complex pipeline
$ cat *.log | grep ERROR | sort | uniq > errors.txt

# Redirect stderr to stdout, then pipe
$ command 2>&1 | grep "error"
```

### What to Know

- Pipe (|): connect commands
- < : input from file
- > : output to file (overwrite)
- >> : output to file (append)
- 2> : redirect stderr
- &> : redirect both
- /dev/null : discard output
- **Medium exam impact** - understand concepts

---

## SECTION 36: Threads Introduction ‚≠ê‚≠ê
**Slides 2-15 | Exam Relevance: Low-Medium (Background)**

### 36.1 Thread Concepts ‚≠ê‚≠ê

**Process Limitations:**
- Heavyweight (much memory)
- Expensive creation
- Expensive context switching
- IPC overhead for cooperating processes

**Thread Solution:**
- Lightweight process
- Share address space
- Multiple execution flows in one process
- Cheaper creation and switching

**Thread = CPU scheduling unit**
**Process = Resource grouping unit**

### 36.2 Thread Characteristics ‚≠ê‚≠ê

**Shared Among Threads (Same Process):**
- Code section
- Data section (global variables)
- Heap (malloc allocations)
- File descriptors
- Signals

**Private to Each Thread:**
- Program counter (PC)
- Registers
- Stack (local variables)

**Advantages:**
- 10-100x faster creation than process
- Automatic data sharing
- Lower memory overhead
- Better scalability on multi-core

**Disadvantages:**
- No memory protection between threads
- No parent-child hierarchy
- Must synchronize shared data access
- Not thread-safe without synchronization

### 36.3 Thread Models ‚≠ê‚≠ê

**Three Models:**

**1. User-Level Threads:**
- Managed by user library
- Kernel unaware
- Fast context switch
- Cannot use multiple CPUs

**2. Kernel-Level Threads:**
- Managed by kernel
- System call overhead
- Can use multiple CPUs
- Better for I/O-bound

**3. Hybrid:**
- Both user and kernel threads
- Flexible mapping

### What to Know (Brief)

- Thread = lightweight process
- Shares: code, data, files
- Private: PC, registers, stack
- Faster than process creation
- No memory protection
- **Low exam impact** - background for synchronization

---

## SUMMARY: Pages 501-600 Key Concepts

### CRITICAL MEMORIZATION CHECKLIST:

**alarm():**
- [ ] alarm(seconds) sets timer
- [ ] Generates SIGALRM
- [ ] alarm(0) cancels
- [ ] Only one per process
- [ ] Install handler before alarm

**Signal Limitations:**
- [ ] Max one pending per type
- [ ] Additional signals lost
- [ ] Reentrant: read, write, wait
- [ ] Non-reentrant: printf, malloc
- [ ] Race conditions with alarm/pause

**Pipes (MOST IMPORTANT!):**
- [ ] pipe(fd) before fork()
- [ ] fd[0] = read, fd[1] = write
- [ ] Close unused ends immediately
- [ ] Close write end for EOF
- [ ] read() blocks if empty, returns 0 if writers closed
- [ ] write() blocks if full, SIGPIPE if readers closed
- [ ] Pipe size ~64 KB

**IPC:**
- [ ] Shared memory: fast, large data
- [ ] Message passing: slow, small data
- [ ] Pipes: half-duplex, limited capacity

**Shell:**
- [ ] | : pipe between commands
- [ ] > : redirect output
- [ ] < : redirect input
- [ ] 2> : redirect stderr

### EXAM STRATEGY:

**Time Allocation:**
- Pipe questions: 7-10 minutes each
- alarm() questions: 3-5 minutes
- Signal limitations: 2-3 minutes
- IPC concepts: 2-3 minutes

**Common Traps:**
‚ùå Creating pipe after fork
‚ùå Not closing unused ends
‚ùå Not closing write end (child hangs)
‚ùå Confusing fd[0] and fd[1]
‚ùå Thinking pipe is full-duplex
‚ùå Forgetting SIGPIPE on write to closed pipe
‚ùå Not handling signal before alarm()

**Pipe Problem Checklist:**
1. ‚úì pipe() before fork()?
2. ‚úì Close unused ends?
3. ‚úì Close write end for EOF?
4. ‚úì Using fd[0] for read, fd[1] for write?
5. ‚úì Handling blocking correctly?

---

**End of Pages 501-600 Study Guide**
**Total Coverage: Pages 1-600 Complete**

**üî• With 600 pages covered, you have 85-90% of typical OS exam content! üî•**

**Priority for Study:**
1. **Pipes** (40% of this section) - Master completely
2. **fork() + pipes** (combined questions are common)
3. **alarm() + signals** (20% of this section)
4. **Signal limitations** (10%)
5. **IPC concepts, shell, threads** (background)
